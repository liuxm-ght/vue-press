### 1. 输入url之后发生了什么（高频，必问）
  1. 大体流程：
    1. URL解析
    2. DNS查询
    3. TCP连接
    4. HTTP请求
    5. 数据响应
    6. 渲染页面

  2. 简答：
    1. URL解析，DNS域名查询，找到对应的ip地址
    2. 建立TCP连接，发起HTTP请求，返回数据
    3. 根据数据类型处理，开始渲染页面
    4. 解析HTML文档生成DOM TREE，同时解析CSS资源生成CSSOM TREE，
    5. 将DOM TREE 与 CSSOM TREE合成Renderer Tree
    6. 根据Renderer Tree的信息进行布局Layout
    7. 布局完成，根据信息，进行绘画Paint
    8. JS编译执行

#### 详细答案：
  1. URL解析 ( Brower Process -> UI thread ->  Network Process )
      1. 地址解析
        当输入一个url字符串时，浏览器进程会调用UI线程去处理这个url字符串，判断它是否为 合法的URL  还是 搜索的关键词；
          并且根据你输入的内容自动完成字符编码工作；
          1. 如果是合法的URL，交给 Network Process
          2. 如果是搜索关键词，将信息发送给搜索引擎
      2. HSTS 
        由于安全隐患（例如中间人劫持），浏览器会强制使用HTTPS访问页面
      3. 其他操作
        比如安全检查、访问限制（之前国产浏览器限制 996.icu）
      4. 检查缓存
         Network Process根据url信息，初始一个网络请求来请求网站内容；此时tab是loading旋转状态的图标；
        检查域名过程是： Network Process会进行一系列的DNS查询
        检查结果判断是：《浏览器缓存机制.md》过程

  2. DNS查询(检查域名过程)(  Network Process )
    1. 浏览器缓存
       Network Process会先去浏览器DNS缓存中查找，有直接返回ip，没有则调用系统库函数进行查询。
    2. 操作系统缓存
      向操作系统中的Hosts文件查询，没有下一步
    3. 本地DNS系统(LDNS)
      向本地DNS服务器(ISP服务器或者自己手动设置的DNS服务器)查询，没有下一步
    上面3步是递归查询 ： 一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）
    下面是迭代查询： 查询到一个返回，拿上一个结果去下一个查询
    4. 根DNS服务器(.域名)
      全球就13台，向其中一台查询，发现是.com.或.cn.，返回.com或.cn的域名服务器地址 给本地DNS服务器
    5. 顶级DNS服务器(TLD .com)
      本地DNS服务器继续向TLD查询，发现是a.com.,返回a.com的域名服务器地址 给本地DNS服务器
    6. 主DNS服务器(权威DNS服务器)
      本地DNS服务器继续向权威DNS服务器查询，返回最终ip地址 给本地DNS服务器，最终返回给浏览器，浏览器可以向ip访问了
    
  3. TCP连接(  Network Process )
    1. TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：
    2. 三次握手，四次挥手
    详情见 《TCP/ip》篇
    * 如果是HTTPS请求，TCP连接后不是直接HTTP请求，而是进过SSL/TLS连接。
    
  4. 服务器处理请求(  Network Process -> UI thread / Brower Processs )
    1. 接受TCP报文后，对连接进行处理，解析HTTP协议(请求方法、域名、路径等),并且进行一些验证：
      验证是否配置虚拟主机
      验证虚拟主机是否接受此方法
      验证该用户可以使用该方法（根据 IP 地址、身份信息等）
    2. 重定向 (  Network Process -> UI thread )
      假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。
    3. URL 重写 (  Network Process -> UI thread )
      然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。

  5. 浏览器接受响应(  Network Process -> Brower Process)
    浏览器接收到来自服务器的响应资源后，会对资源进行分析。根据响应头的content-type的类型来解析文件

  6. 渲染页面( Brower Process -> Renderer Process ->  ) CRP 关键渲染路径
      * 浏览器内核
        chrome ： blink 、 safari ： webkit 、 微软ie ： trident
      * 基本流程：
        1. 在UI thread 通知  Network Process去处理请求时，UI thread会同时向Brower Process申请开启一个Renderer Process，在请求数据准备好及Renderer Process开启后，Brower Process 通过IPC(Internet Process Comunication)通知 Renderer Process 去提交本次导航，当浏览器进程接受到响应数据后会传递给渲染进程，当渲染进程接收到响应数据初步处理后会回复浏览器进程说导航已经被提交了(commit)，至此导航这个过程结束了，开始文档加载阶段。
        2. 至此，导航栏会被更新，安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息。当前tab的会话历史（session history）也会被更新(顾可以前进后台历史记录)，同时当前会话历史会被保存到磁盘上面。
        3. 一旦渲染进程完成渲染页面，会通过IPC通知浏览器进程(注意：这发生在页面上所有帧(frames)的onload事件都被触发了，且处理函数已经执行完毕的时候)，然后UI线程会停止导航栏上的loading旋转。

      * 下面才是重要的(发生在一个tab里的事情)
      1. HTML解析 (GUI线程(GUI thread))
          Bytes → characters → tokens → nodes → DOM
          1. 主要两步骤：
            1. 标记化(词法分析)：标记生成器/解析器
              1. 转码（encoding）
                  将字节数据，根据指定的编码（例如UTF-8）转为字符串,就是HTML代码
              2. 预解析（pre-parsing）
                  预解析的作用是，提前加载资源，减少处理时间，它会识别请求资源属性，比如img标签的src，并将这个请求加入请求队列
              3. 符号化（令牌化Tokenization）
                符号化是词法分析的过程，将字符串转为符号Token。(或叫HTML标记过程)
                HTML符号主要有：开始标签、结束标签、文本等。即Token的类别有：Tag Token和文本Token
                * HTML标记，使用状态机表示。状态机一共有4个状态：数据状态(Data)、标记打开状态(Tag open)、标记名称状态(Tag name)、关闭标记打开状态(Close tag open state)。初始状态是数据状态。
                    具体过程是：
                      1. 解析器会遍历每个字符进行状态标记，遇到<，状态标记为“标记打开状态”，
                        1. 此时遇到a-z状态标记为“起始标记”，并保持到>字符，此期间的所字符串形成一个新的标记名称。遇到到>字符，状态标记为“关闭标记打开状态”，同时将当前的新标记发送给树构造器(此时构造器同时进行着)，状态改为“数据状态”。
                        2. 接收下一个输入字符/时，会创建关闭标记打开状态，并更改为“标记名称状态”。直到接收>字符，将当前的新标记发送给树构造器，并改回“数据状态”。
                      2. 遇到a-z字符时，会将每个字符创建成字符标记，并发送给树构造器。此时构造器同时进行着。
                      * 解析的过程中，GUI线程有很强的容错机制，防止出现页面解析错误的情况
              4. 构建Nodes
                将发出的令牌(Token/标记)转为Node对象(定义了这个节点的属性和规则的对象)
            2. 树构建(语法分析)：树构造器
              4. 构建树（tree construction）
                * 注意：符号化和构建树是并行操作的，就是说解析到一个开始标签，就构建一个Dom节点
                * 在创建解析器的同时，也会创建 Document 对象。
                在符号化的过程中，生成一个标记对象(node)会发送给树构造器，构造器接收到标记对象(node)后，会将标记对象(node)压入其维护的一个栈中去，同时往 Document对象 上添加一个DOM节点，如果是文本标记对象(node)\没闭合标签的标记对象(node)，那么直接加到DOM上去，不压入栈，如果是结束标签不会入栈，但会跟栈顶元素匹配，如果匹配上，弹出栈顶，处理层级关系，继续接受后面的标记对象(node)。当栈空了，即html标记对象(node)也加入dom了，DOM树构建完毕。
                    <!-- (我的理解是，解析器维护了一个栈，符号化过程中遇到一个开始标签就入栈，并创建一个DOM对象，继续解析，遇到非结束标签继续生成Token并压入栈，同时创建一个DOM对象，添加一个parent属性指向前一个Token，直到遇到结束Token，弹出栈顶Token(即销毁了)，加它的parent的children数组中，这样就维护了DOM tree的关系) -->
                    <!-- https://blog.csdn.net/Alan_1550587588/article/details/80297765 -->
                    <!-- http://www.dailichun.com/2018/03/12/whenyouenteraurl.html -->
      2. CSS 解析 (GUI线程(GUI thread))
          1. 解析CSS生成 规则表
            css资源加载完成后，Css解析器(即GUI线程或者说呈现引擎)会根据语法规范来解析出所有的CSS并进行标记化，然后我们可以获得一个规则表
      3. 渲染树 (GUI线程(GUI thread))
          根据DOM树和CSS规则树进行合并生成Renderer树，Renderer树是由一个个包含颜色和大小等属性信息的矩形组成的。
          生成的大致工作如下：
          1. 遍历DOM树，每个节点去匹配css规则，给他们添加的样式信息，最终生成渲染树
          * css匹配规则(CSS 匹配发生在 Render Tree 构建时)
            css在匹配一个节点的时候，是按照从右往左的顺序的，例如： div a { color:red} 会先寻找所有的a标签，然后去判断它的父元素是否为div。所以在写css的时候尽量使用id 或 class，避免深层嵌套
            <!-- 从右往左匹配的原因是：
              1. 但是对于前者，由于 CSS 的庞大，一个 CSS 文件中或许有上千条规则，而且对于当前节点来说，大多数规则是匹配不上的，到此为止，稍微想一下就知道，如果从右开始匹配（也是从更精确的位置开始），能更快排除不合适的大部分节点，而如果从左开始，只有深入了才会发现匹配失败，如果大部分规则层级都比较深，就比较浪费资源了。
              2. DOM 构建是"循序渐进的"，而且 DOM 不阻塞 Render Tree 构建（只有 CSSOM 阻塞），这样也是为了能让页面更早有元素呈现。考虑如下情况，如果我们此时构建的只是部分 DOM，而 CSSOM 构建完成，浏览器就会构建 Render Tree。这个时候对每一个节点，如果找到一条规则从右向左匹配，我们只需要逐层观察该节点父节点是否匹配，而此时其父节点肯定已经在 DOM 上。但是反过来，我们可能会匹配到一个 DOM 上尚未存在的节点，此时的匹配过程就浪费了资源。 -->
      4. 布局(GUI线程(GUI thread))
        遍历渲染树，计算渲染树上所有元素的几何属性(元素在浏览器的确切位置和大小等)，最后得到的是计算好的布局树(layout tree)
        * 注意：布局树会忽略那些不需要渲染的节点，比如设置了display:none的节点。visibility:hidden的节点会出现在布局树上面。
        <!-- Layout 输出元素的Box Model（盒模型） -->
      5. 绘制(GUI线程(GUI thread))
        1. 在绘画之前，根据布局树，生成一个图层树(Layer Tree)。
        2. 遍历图层树，将图层的绘制拆分成一个个绘制指令，来生成一系列的绘制列表(绘画记录)（paint records），确定每个元素的绘制顺序
          * 如何分层的？有显式合成 和 隐式合成。
      6. 合成(合成线程 compositor thread)
        到目前为止，浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。
        那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。
          1. 光栅化(光栅线程 raster thread 与 合成线程 合作)： 
            合成线程，会遍历图层树，光栅化所图层，将图层拆分为小块，交给光栅线程处理生成位图并存入(传给浏览器进程，再传出给显卡GPU)GPU的内存中。
            * 以前的做法是仅仅绘制的是当前窗口的图像，当窗口移动的时候，才会将尚未绘制的部分进行删格化。
            * 现在的做法是：将页面分为若干块，然后分别进行了光栅化，然后调用合成线程将他们合成一个页面的技术。
              <!-- 当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。 -->
          2. 合成(合成线程 compositor thread)
            当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。
              * 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。
              * 合成帧：代表页面一个帧的内容的绘制四边形集合。
          3. 发送(IPC)
            上面的步骤完成之后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个(渲染帧)。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。
        最终浏览器根据这个合成帧，提交给GPU处理，从而在屏幕上输出一张图片
          <!-- https://zhuanlan.zhihu.com/p/102149546 -->
          * 合成的好处是，显示的过程不用到主线程，不会阻塞样式计算和js执行。
        

      * 总结：
        渲染的流水线是这样的：
          主线程：生成DOM树 -> 计算样式 -> 生成布局树 -> 建图层树 -> 绘制列表 ->
          主线程之外：分图块(合成线程中) -> 生成位图(发送) -> 浏览器进程 -> 显卡缓存 -> 显示器

  7. 参考链接
    <!-- https://zhuanlan.zhihu.com/p/80551769 -->
### 2.回流与重绘
  1. 回流 ： 简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。
      回流过程 ： 如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。
  2. 重绘 ： 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。
      重绘过程 ：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。
              跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。
              可以看到，重绘不一定导致回流，但回流一定发生了重绘。

### 3. GPU加速
  1. 什么是GPU加速
    是直接合成。比如利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。
  2. 加速原因
    直接合成，跳过了布局和绘制流程
    在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处:
      1. 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。
      2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。


#### 参考文章
  一文看懂Chrome浏览器运行机制
  https://zhuanlan.zhihu.com/p/102149546

  在浏览器输入 URL 回车之后发生了什么（超详细版）
  https://zhuanlan.zhihu.com/p/80551769
      



### 4. 面试题网址
    「浏览器工作原理」写给女友的秘籍-浏览器组成&网络请求篇（1.2W字)
    https://juejin.cn/post/6846687590540640263

    11道浏览器原理面试题
    https://juejin.cn/post/6844903951377104903#heading-6

    (1.6w字)浏览器灵魂之问，请问你能接得住几个？
    https://juejin.cn/post/6844904021308735502#heading-0