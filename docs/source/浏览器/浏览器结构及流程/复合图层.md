### 复合图层
  1. 普通图层和复合图层
    * 渲染步骤中就提到了composite概念。
    可以简单的这样理解，浏览器渲染的图层一般包含两大类：
      * 普通图层
      * 复合图层
    1. 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）
       其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。
    2. 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）
    <!-- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒
    可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息 -->
  2. 如何变成复合图层（硬件加速）
    1. 将该元素变成一个复合图层，就是传说中的硬件加速技术
      * 最常用的方式：translate3d、translateZ
      * opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
      * will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），
        作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
      * < video>< iframe>< canvas>< webgl>等元素
      * 其它，譬如以前的flash插件
  3. absolute和硬件加速的区别
    1. absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。
    2. 所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）
    4. 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）
  4. 复合图层的作用？
    * 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能
    * 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡
    * 硬件加速时请使用index
        使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染
        具体的原理时这样的：
          webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，
          那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），
          会默认变为复合层渲染，如果处理不当会极大的影响性能
        <!-- 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 -->
        <!-- 另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：
        web.jobbole.com/83575/ -->
