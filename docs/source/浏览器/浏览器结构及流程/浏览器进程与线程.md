### Chrome浏览器运行机制
  * 超全面认识浏览器
  一文看懂Chrome浏览器运行机制
  <!-- https://zhuanlan.zhihu.com/p/102149546 -->

#### 浏览器进程和线程
  <!-- https://juejin.cn/post/6844903553795014663#heading-11 -->
  1. 区分进程和线程
    线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：
      - 进程是一个工厂，工厂有它的独立资源
      - 工厂之间相互独立
      - 线程是工厂中的工人，多个工人协作完成任务
      - 工厂内有一个或多个工人
      - 工人之间共享空间
    再完善完善概念：
      - 工厂的资源 -> 系统分配的内存（独立的一块内存）
      - 工厂之间的相互独立 -> 进程之间相互独立
      - 多个工人协作完成任务 -> 多个线程在进程中协作完成任务
      - 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
      - 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
    应该更容易理解了：进程是cpu资源分配的最小单位（系统会给它分配内存）

  2. 浏览器是多进程的
    浏览器是多进程的
    浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
    简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。

  3. 浏览器都包含哪些进程？
    1. 浏览器进程(Browser Process)：浏览器的主进程（负责协调、主控），只有一个。作用有
        负责浏览器界面显示，与用户交互。如前进，后退等
        负责各个页面的管理，创建和销毁其他进程
        将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
        网络资源的管理，下载等
        主要线程有：
          UI线程(UI thread)： 绘制浏览器顶部按钮和导航栏输入框等组件的
          存储线程(storage thread)： 控制文件读写的
    2. 第三方插件进程(Plugin Process)：每种类型的插件对应一个进程，仅当使用该插件时才创建
    3. 图形处理器进程(GPU Process)：最多一个，用于3D绘制等
    4. 浏览器渲染进程(Renderer Process)（内部是多线程的）：默认每个Tab页面一个进程，互不影响。
        渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。
        主要作用为:
          页面渲染，脚本执行，事件处理等
        主要线程有：
          主线程(main thread): GUI渲染线程、JS引擎线程
          合成线程(compositor thread): 将图块转换成位图
          光栅线程(raster thread): 
          工作线程(worker thread): 事件触发线程、定时触发器线程、异步http请求线程、web worker、server worker
    5. 网络进程(Network Process)： 管理网络请求的，负责真正的发送http请求，接收和发送网络请求。
    强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

  4. 浏览器多进程的优势
    1. 相比于单进程浏览器，多进程有如下优点：
    2. 避免单个page crash影响整个浏览器
    3. 避免第三方插件crash影响整个浏览器
    4. 多进程充分利用多核优势
    5. 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
    简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。
    当然，内存等资源消耗也会更大，有点空间换时间的意思。

  5. 重点是浏览器内核（渲染进程）
      浏览器的渲染进程是多线程的，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。
      1. GUI渲染线程
        * 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
        * 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
        * 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
      2. JS引擎线程
        * 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
        * JS引擎线程负责解析Javascript脚本，运行代码。
        * JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
        * 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
      3. 事件触发线程
        * 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
        * 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
        * 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
        * 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
      4. 定时触发器线程
        * 传说中的setInterval与setTimeout所在线程
        * 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
        * 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
        * 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
      5. 异步http请求线程
        * 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
        * 将检测到readyState状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

  6. 从Event Loop谈JS的运行机制
      详情见 《事件循环机制篇》
      根据线程来理解下：
        macrotask中的事件都是放在一个事件队列中的，而这个队列由(事件触发线程)维护
        microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由(JS引擎线程)维护
        * (JS引擎线程)维护了一个执行栈，栈里存放了当前环境的上下文，执行完栈里的所有上下文后，检查微任务队列，全部加入执行栈，执行完后，进入下一轮
        从(事件触发线程)维护的队列中，拿出一个任务，放执行栈执行， 执行完，再去检查微任务队列，全部加入执行栈，执行完后，进入下一轮

  7. 从运行机制简单理解浏览器渲染流程：
      1. 浏览器输入url，Browser进程接管，开启一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
      2. 随后将内容通过RendererHost接口转交给Renderer进程
      3. 浏览器渲染流程开始，Renderer进程开始处理，开启GUI渲染线程处理HTML\CSS,JS引擎线程处理js脚本....


#### 说下浏览器的进程、线程模型，线程模型中的每个线程都是干嘛用的？
  1. Chrome为例，有四种进程模型，分别是
    Process-per-site-instance：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程不会创建
    Process-per-site：同一站点使用同一进程
    Process-per-tab：每一个标签页都创建新的进程
    Single Process：单进程模式

  2. 线程模型中的线程都是干嘛的呢？
    MessagePumpForIO：处理进程间通信的线程，在Chrome中，这类线程都叫做IO线程
    MessagePumpForUI：处理UI的线程用的
    MessagePumpDefault：一般的线程用到的
  每一个Chrome的线程，入口函数都差不多，都是启动一个消息循环，等待并执行任务

#### 你知道哪些进程间通信的方式？
  1. 管道通信：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了
  2. 消息队列通信：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制
  3. 共享内存通信：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式
  4. 信号量通信：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了
  5. socket：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

#### 多标签之间怎么通信？
  没有办法直接通信，需要有一个类似中介者进行消息的转发和接收，比如
  1. localStorage：在一个标签页监听localStorage的变化，然后当另一个标签页修改的时候，可以通过监听获取新数据
  2. WebSocket：因为websocket可以实现实时服务器推送，所以服务器就可以来当这个中介者。标签页通过向服务器发送数据，然后服务器再向其他标签推送转发
  3. ShareWorker：会在页面的生命周期内创建一个唯一的线程，并开启多个页面也只会使用同一个线程，标签页共享一个线程
  4. postMessage：
    // 发送方
    window.parent().pastMessage('发送的数据','http://接收的址')
    // 接收方
    window.addEventListener('message',(e)=>{ let data = e.data })

#### 你知道僵尸进程和孤儿进程吗？
  1. 孤儿进程：故名思义，就是没爹的孩子。父进程退出了，而它的一个或多个进程还在运行，那么这些子进程都会成为孤儿进程。这些孤儿都将被init进程收养，并负责这些孤儿的以后

  2. 僵尸进程：就是子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的描述还留在系统中，这种进程就是僵尸进程

<!-- 链接：https://juejin.cn/post/6991849728493256741 -->