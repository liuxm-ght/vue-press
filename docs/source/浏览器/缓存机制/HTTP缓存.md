### 浏览器缓存机制（HTTP 缓存）
  介绍：
    浏览器缓存可以提高网页打开速度、减少 Http 请求，在提高用户体验、重复利用资源、减少网络带宽上发挥着重要的作用。
    所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。
    浏览器缓存过程： 强缓存，协商缓存。

  #### 强缓存
  1. 介绍：
    * 强缓存命中不会发送请求到服务器端，直接从本地缓存中获取资源，状态码 200 ( from cache )

  2. 如何设置？
    1. 第一次请求，服务端返回响应头包含缓存策略，浏览器根据响应头response-header设置数据是否缓存，
      如果有expires、cache-control、pragma，表示设置强缓存，浏览器会把数据缓存到memory cache或disk cache
    2. 第二次请求，浏览器会判断请求头的缓存策略，发起请求（不发送到服务端），如果符合缓存条件，返回200状态，从本地缓存中拿数据；
      如果不符合，则把响应参数存请求头，发送服务端请求，看是否符合协商缓存，符合返回304状态，不符合返回200状态及新数据，并存入缓存

  3. 字段：  
      1. expires: http 1.0 ，一个时间戳，格林时间，下次请求时判断是否过期，不过期命中强缓存
              缺点： 判断是否过期是拿expires时间跟本地时间来比对的，本地时间可改变
      2. cache-control: http 1.1  取值有：
          no-cache: 客户端缓存资源，但是否缓存看需要经过协商缓存来验证
          no-store: 不缓存
          max-age:  缓存保质期，相对时间
          private: 资源只有客户端缓存
          public: 资源服务端、客户端可缓存
      3. pragma: http 1.0 no-cache 功能与 cache-control 的no-cache一样

    命中缓存条件：
      ...
      cache-control: max-age 或 expires 时间大于请求时间

    注意：
      如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 Expires 信息，是不是就不会命中强缓存了呢？不是的，浏览器会做出优化，默认采用一个启发式算法，取响应头的 (Date - Last-Modified) * 0.1 作为缓存有效时间，只要是在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存。

    4. 请求流程： 
        1. 命中缓存流程：
          向浏览器缓存发起请求，有缓存数据，且未失效，返回数据，返回200

        2. 未命中缓存流程：
          向浏览器缓存发起请求，缓存数据失效，重新向服务器发起请求，返回数据，同时根据缓存规则写入浏览器缓存，返回200


  #### 弱缓存
    1. 介绍：
      协商缓存会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，则返回状态码 304 ( not modified )，通知浏览器从缓存中获取资源。
      协商缓存主要是在服务端校验的。
    
    2. 如何设置？
      第一次请求，服务端返回协商缓存字段：Last-Modified、Etag，浏览器根据响应头设置请求头
      第二次请求，浏览器请求头携带协商缓存字段：If-Modified-Since、If-None-Match，服务端根据请求头字段判断是否命中协商缓存，
        如果命中，返回304状态码，浏览器根据状态码去本地缓存中拿数据；
        如果未命中，返回200状态码，同时返回数据，浏览器拿到数据和缓存规则存入缓存
    
    3. 字段:
      1. Last-Modified\If-Modified-Since:
        Last-Modified 服务端返回的，代表该资源最后的修改时间
        If-Modified-Since 上次服务端返回的资源的最后修改时间，浏览器发送到服务端，服务端拿这个时间来比对服务端的时间
        无改变，返回304，浏览器到本地缓存拿数据
        有改变，返回200，服务端返回数据及新的修改时间，浏览器拿到新数据及时间修改，存入缓存


      2. Etag\If-None-Match:
        Etag 服务端返回的，代表该资源的hash值
        If-None-Match 上次服务端返回的代表该资源的hash值，浏览器发送到服务端，服务端拿到这个值与服务端的hash值比对
        无改变，返回304，浏览器到本地缓存拿数据
        有改变，返回200，服务端返回数据及新的hash，浏览器拿到新数据及hash，存入缓存
    
    4. 优点：
      * Etag的优先级高于Last-Modified
      为啥？ 
        1. 有些服务器不能精准的记录资源的最后修改时间
        2. 如果资源短时间内频繁修改，Last-Modified最小计数是秒，可能会有错误认为没改动
        3. 一些资源的最后修改时间改动了，但是资源没改动，Last-Modified也会返回新数据，Etag不会

    5. 协商缓存请求流程：
        当强缓存失效后，发现有协商缓存字段
        1. 命中缓存： 
          1. 向浏览器缓存发起请求，获取缓存标识
          2. 拿缓存标识，向服务端发起请求，校验标识是否有效，有效返回304，代表资源无更新
          3. 拿缓存标识，向浏览器缓存获取缓存数据

        2. 未命中缓存：
          1. 向浏览器缓存发起请求，获取缓存标识
          2. 拿缓存标识，向服务端发起请求，校验标识是否有效，无效返回200，同时返回新数据
          3. 将新数据和缓存标识存入浏览器缓存中


  ##### 刷新对缓存的影响
  1. ctrl+f5 跳过所有缓存
  2. f5 跳过强缓存，去协商缓存拿
  3. url栏输入，判断强缓存，无，判断协商缓存
  
  ##### 强缓存与协商缓存的区别
  1. 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。
  2. 大部分web服务器都默认开启协商缓存。

  ##### 缓存方案
    目前的项目大多使用这种缓存方案的：
      HTML: 协商缓存；
      css、js、图片：强缓存，文件名带上hash。

#### 缓存位置（HTTP主要的缓存位置）
  浏览器会自动分配缓存的位置，查找的时候也是按下面顺序查找的
  2. Memory Cache （内存）
    内存中的缓存，主要包含的是 当前中页面 中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。
    读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。
    一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
    特点： 容量小、读取快、持续短

  3. Disk Cache （硬盘）
    存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
    在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
    memory cache 要比 disk cache 快的多。举个例子：从远程 web 服务器直接提取访问文件可能需要500毫秒(半秒)，那么磁盘访问可能需要10-20毫秒，而内存访问只需要100纳秒，更高级的还有 L1缓存访问(最快和最小的 CPU 缓存)只需要0.5纳秒。
    特点： 容量大、读取慢、持续长

    prefetch cache(预取缓存)
      link标签上带了prefetch，再次加载会出现。
      prefetch是预加载的一种方式，被标记为prefetch的资源，将会被浏览器在空闲时间加载。