[[toc]]

## V3 更小
  1. Proxy替代Object.defineProperty，减少了循环代码
  2. Tree-shaking删除掉未使用的变量或模块

### Proxy-响应式系统
  1. V2的缺点
      ::: warning
      vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式

      调用defineReactive，数据发生变化触发update方法，实现数据响应式
      ```ts
      const obj = {}
      defineReactive(obj, 'foo', '')
      setTimeout(()=>{
          obj.foo = new Date().toLocaleTimeString()
      },1000)
      ```
      :::

      1. 在对象存在多个key情况下，需要进行遍历
      ```ts
      function observe(obj) {
        if (typeof obj !== 'object' || obj == null) {
          return
        }
        Object.keys(obj).forEach(key => {
          defineReactive(obj, key, obj[key])
        })
      }
      ```

      2. 如果值val是对象或数组，需要在defineReactive中进行递归
      ```ts
      function defineReactive(obj, key, val) {
        observe(val)
        Object.defineProperty(obj, key, {
          get() {
            console.log(`get ${key}:${val}`);
            return val
          },
          set(newVal) {
            if (newVal !== val) {
              val = newVal
              update()
            }
          }
        })
      }
      ```

      3. 如果给key赋值为对象时，需求进行递归处理
      ```ts
      set(newVal) {
        if (newVal !== val) {
          observe(newVal) // 新值是对象的情况
          notifyUpdate()
        }
      }
      ```

      4. 除了上述问题，还有两个问题
          1. 当对对象进行删除或添加属性时，无法劫持到
          2. 当对数组进行新增或删除元素时，无法劫持到
          * 针对上面的问题，V2还添加了set 、delete的API，供用户给对象删除、添加新属性
          * 重写了数组的一些常用API，方便用户操作数组


  2. V3的优点
      * 可以监听动态属性的添加
      * 可以监听到数组的索引和数组length属性
      * 可以监听删除属性

  3. Proxy
      1. Proxy代理的是对象本身
      2. 顾可以监听到对象的添加、删除等操作，同时包括一些常用的has、getPropertypeOf、apply等操作也能监听到
      3. 但同样不能深度监听，需要在get中进一层代理
      ```ts
      function reactive(obj) {
        if (typeof obj !== 'object' && obj != null) {
            return obj
        }
        // Proxy相当于在对象外层加拦截
        const observed = new Proxy(obj, {
          get(target, key, receiver) {
              const res = Reflect.get(target, key, receiver)
              console.log(`获取${key}:${res}`)
              return isObject(res) ? reactive(res) : res
          },
          return observed
        })
      }
      ```
      ::: warning
      在get中处理是为了防止无脑的对数据进行深度劫持，而是在用到的数据才进行深度劫持
      :::



### Tree-shaking
  1. Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination

  2. V2 与 V3区别
      1. 在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到
      ```ts
      import Vue from 'vue'
      Vue.nextTick(() => {})
      ```

      2. 而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中
      ```ts
      import { nextTick, observable } from 'vue'
      nextTick(() => {})
      ```
  
  3. 原理
      * Tree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

      * Tree shaking无非就是做了两件事：
          1. 编译阶段利用ES6 Module判断哪些模块已经加载
          2. 判断那些模块和变量未被使用或者引用，进而删除对应代码

