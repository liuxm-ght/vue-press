[[toc]]

### 前提
  不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下Vue3之前我们或许会面临的问题

  * 随着功能的增长，复杂组件的代码变得越来越难以维护
      * 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制
      * 类型推断不够友好
      * bundle的时间太久了

  * 而 Vue3 经过长达两三年时间的筹备，做了哪些事情？我们从结果反推
      * 更小
      * 更快
      * TypeScript支持
      * API设计一致性
      * 提高自身可维护性
      * 开放更多底层功能
      一句话概述，就是更小更快更友好了

### V2 和 V3 的区别
  1. 重构响应式系统，使用proxy替代Object.defineProperty

    使用proxy的优势在于：
      1. 监听的目标为对象本身，而不是对象属性，这样对象的增删改查都能监听到，提升性能
      2. 可直接监听数组的变化
      3. 可拦截apply、ownkeys、has等13种方法

  2. compositiom API，提高逻辑复用和代码组织
      1. mixin重用代码不利于跟踪来源和容易变量冲突
      2. options API是类型区分，composition API是功能区分，更好的代码提前和tree-shaking

  3. 重构虚拟dom
      1. 模板编译时优化，将静态节点变量提升
      2. slot优化成lazy函数，交给子组件去决定是否渲染
      3. 模板内联事件的提取并缓存重用

     虚拟DOM新算法（更快、更小）
      * 更快
          1. virtual DOM 完全重写，mounting & patching 提速 100%；
          2. 更多编译时 （compile-time）提醒以减少 runtime 开销；
          3. 基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能；
          4. 放弃 Object.defineProperty ，使用更快的原生 Proxy；
          5. 组件实例初始化速度提高 100%;
          6. 提速一倍/内存使用降低一半；

      * 更小
          1. Tree-shaking 更友好；
          2. 新的 core runtime：~ 10kb gzipped
            ④：提供了composition api，为更好的逻辑复用与代码组织
            ⑤：自定义渲染器（app、小程序、游戏开发）
            ⑥：Fragment，模板可以有多个根元素

  4. 基于esm，实现更好的tree-shaking

  5. 使用ts替代flow


### V3 优点
  * [速度更快](./v3更快.md)
  * [体积减少](./v3更小.md)
  * [更易维护](./v3更易.md)
  * 更接近原生
  * [更易使用](./v3更易.md)

### 非兼容变更
1. Global API
    * 全局 Vue API 已更改为使用应用程序实例
    * 全局和内部 API 已经被重构为可 tree-shakable

2. 模板指令
    * 组件上 v-model 用法已更改
    * < template v-for>和 非 v-for节点上key用法已更改
    * 在同一元素上使用的 v-if 和 v-for 优先级已更改
    * v-bind="object" 现在排序敏感
    * v-for 中的 ref 不再注册 ref 数组

3. 组件
    * 只能使用普通函数创建功能组件
    * functional 属性在单文件组件 (SFC)
    * 异步组件现在需要 defineAsyncComponent 方法来创建

4. 渲染函数
    * 渲染函数API改变
    * $scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露
    * 自定义指令 API 已更改为与组件生命周期一致
    * 一些转换 class 被重命名了：
        * v-enter -> v-enter-from
        * v-leave -> v-leave-from
    * 组件 watch 选项和实例方法 $watch不再支持点分隔字符串路径，请改用计算函数作为参数
    * 在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。VUE3.x 现在使用应用程序容器的 innerHTML。

5. 其他小改变
    * destroyed 生命周期选项被重命名为 unmounted
    * beforeDestroy 生命周期选项被重命名为 beforeUnmount
    * [prop default工厂函数不再有权访问 this 是上下文
    * 自定义指令 API 已更改为与组件生命周期一致
    * data 应始终声明为函数
    * 来自 mixin 的 data 选项现在可简单地合并
    * attribute 强制策略已更改
    * 一些过渡 class 被重命名
    * 组建 watch 选项和实例方法 $watch不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。
    * < template> 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 < template> 元素，而不是渲染其内部内容。
    * 在Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。

6. 移除 API
    * keyCode 支持作为 v-on 的修饰符
    * $on，$off和$once 实例方法
    * 过滤filter
    * 内联模板 attribute
    * $destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。