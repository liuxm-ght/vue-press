[[toc]]

## 更易维护
1. composition API，按功能区分代码，更方便的代码维护和管理
2. TypeScript，类型检查，开发阶段就排除了大部分bug
3. 

### compositon Api
  1. 前提：V2的Options API是根据选项来区分的，同一个功能在不同选项中都可能有代码，不便于维护和代码管理

  2. V3的Composition API则是根据功能来区分的，更方便代码的维护和管理

  3. 特点
      1. 可与现有的Options API一起使用
      2. 灵活的逻辑组合与复用
      3. Vue3模块可以和其他框架搭配使用

  4. 使用
      1. setup 入口

          1. 时机位于beforeCreate和created之前，所以setup中只能访问：props、emit、slots、attrs，不能访问data、watch、refs等
          2. beforeCreate:表示组件刚刚被创建出来，组件的data和methods还没初始化好
          3. created:表示组件刚刚被创建出来，并且组件的data和methods已经初始化好

          ::: warning 注意点
          1. 由于在执行setup函数时候，还没有执行created生命周期方法,所以在setup函数中，是无法使用data和methods
          2. 由于我们不能在setup函数中使用data和methods,所以VUE为了避免我们错误的使用,它直接将setup函数中this修改成了undefined
          3. setup函数只能是同步的不能是异步的[](https://www.csdn.net/tags/NtTaUgxsNjg1NTMtYmxvZwO0O0OO0O0O.html)
          :::

          两个参数：
          1. props: setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。
              ::: warning 
              但是，因为 props 是响应式的，你不能使用 ES6 解构，它会消除 prop 的响应性。

              要解构的话，需要let { title } = toRefs(props) 处理

              如果title是可选项，但没人传入，这时toRefs不会为title创建ref，需要 title = toRef(props,'title')处理

              toRef 将响应式对象的某个属性，转为ref，同时保持对原响应式对象的链接
              :::
          2. context: 暴露了其它可能在 setup 中有用的值：
              ```ts
              export default {
                setup(props, context) {
                  // Attribute (非响应式对象，等同于 $attrs)
                  console.log(context.attrs)

                  // 插槽 (非响应式对象，等同于 $slots)
                  console.log(context.slots)

                  // 触发事件 (方法，等同于 $emit)
                  console.log(context.emit)

                  // 暴露公共 property (函数)
                  console.log(context.expose)
                }
              }
              ```
              * context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构。
              ::: warning
              attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。
              :::

      2. 应用

          下面举个简单例子，将处理count属性相关的代码放在同一个函数了
          ```ts
          function useCount() {
              let count = ref(10);
              let double = computed(() => {
                  return count.value * 2;
              });

              const handleConut = () => {
                  count.value = count.value * 2;
              };

              console.log(count);

              return {
                  count,
                  double,
                  handleConut,
              };
          }
          ```

          组件上中使用count
          ```ts
          export default defineComponent({
              setup() {
                  const { count, double, handleConut } = useCount();
                  return {
                      count,
                      double,
                      handleConut
                  }
              },
          });
          ```

      3. 使用 this
          * 在 setup() 内部，this 不是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆。

      4. 在setup里使用生命周期
          1. beforeCreate和created不能再里面使用，因为setup的功能类似他们
          2. 其他生命周期在setup里应该加上个on，例如onMounted...等，V3中卸载组件的destroyed改为了unmounted，多了renderTriggered用于监听再次渲染
          3. 在setup里的生命周期都应该避免使用this，因为setup里的this被指向了undefined

      5. 在setup 中使用 provide/inject
          ::: warning 
          两者都只能在当前活动实例的 setup() 期间调用。同时provide可以是响应式的
          :::
          用法类似V2的

          1. provide
          ```html
          <!-- src/components/MyMap.vue -->
          <template>
            <MyMarker />
          </template>

          <script>
          import { provide, reactive, readonly, ref } from 'vue'
          import MyMarker from './MyMarker.vue'

          export default {
            components: {
              MyMarker
            },
            setup() {
              const location = ref('North Pole')
              const geolocation = reactive({
                longitude: 90,
                latitude: 135
              })
              //如果要确保通过 provide 传递的数据不会被 inject 的组件更改，使用readonly限制属性
              provide('location', readonly(location)) 
              provide('geolocation', readonly(geolocation))
            }
            //当使用响应式 provide / inject 值时，建议尽可能将对响应式 property 的所有修改限制在定义 provide 的组件内部。
            methods: {
              updateLocation() {
                this.location = 'South Pole'
              }
            }
          }
          </script>
          ```

          2. inject
          ```html
          <!-- src/components/MyMarker.vue -->
          <script>
          import { inject } from 'vue'

          export default {
            setup() {
              const userLocation = inject('location', 'The Universe')
              const userGeolocation = inject('geolocation')

              return {
                userLocation,
                userGeolocation
              }
            }
          }
          </script>
          ```



      6. 在模板中引用


          ```html
          <template>
            <div ref="root">This is a root element</div>
          </template>

          <script>
            import { ref, watchEffect } from 'vue'

            export default {
              setup() {
                const root = ref(null) // 声明ref

                watchEffect(() => {
                  // 这个副作用在 DOM 更新之前运行，因此，模板引用还没有持有对元素的引用。
                  console.log(root.value) // => null
                })

                watchEffect(() => {
                  // 这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。
                  console.log(root.value) // => <div>This is a root element</div>
                }, 
                {
                  flush: 'post'
                })

                onMounted(() => {
                  // DOM 元素将在初始渲染后分配给 ref，并且是响应式的
                  console.log(root.value) // <div>This is a root element</div>
                })

                return {
                  root
                }
              }
            }
          </script>
          ```



      7. 在setup访问组件实例
          1. getCurrentInstance支持访问内部组件实例。

          :::warning
          getCurrentInstance 只能在 setup 或生命周期钩子中调用。
          
          getCurrentInstance 只暴露给高阶使用场景，典型的比如在库中。强烈反对在应用的代码中使用 getCurrentInstance。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。
          :::


### 更好的Typescript支持
  1. VUE3是基于typescipt编写的，可以享受到自动的类型定义提示
  2. TypeScript的使用见[](../../../../TScript/TS/简介.md)

### 编译器重写





### 更接近原生
  1. 可以自定义渲染 API，例如：[createRenderer](../新增功能及用法/V3新特殊.md#createrenderer)

## 更易使用
  1. 响应式 Api 暴露出来

