### 线性表
  堆、栈、队列、链表 是数据结构与算法中的基础知识。
  线性表（Linear List）：
    就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是线性表结构。

#### 数组
  1. 定义
    数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。
    数组的索引是从 0 开始的。
  2. 特点
    ~数组是用一组连续的内存空间来存储的。
    所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。

    ~低效的插入和删除。
    数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。
    插入与删除的时间复杂度如下：
    插入：从最好 O(1) ，最坏 O(n) ，平均 O(n)
    删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)


#### 栈
  1. 定义
    1. 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。
    2. 新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。
    3. 在栈里，新元素都靠近栈顶，旧元素都接近栈底。
    4. 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。
    4. 不包含任何元素的栈称为空栈。
    栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。
  2. 实现
    栈的方法：
      push(element)：添加一个（或几个）新元素到栈顶。
      pop()：移除栈顶的元素，同时返回被移除的元素。
      peek()：返回栈顶的元素，不对栈做任何修改。
      isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。
      clear()：移除栈里的所有元素。
      size()：返回栈里的元素个数。
  3. 应用
    栈的应用实例：JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？
    <!-- 参考文章：https://github.com/biaochenxuying/blog/issues/34 -->


#### 队列
  1. 普通队列
    1. 定义
      队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。
      队列在尾部添加新元素，并从顶部移除元素。
      最新添加的元素必须排在队列的末尾。
      队列只有 入队 push() 和出队 pop()。
    2. 实现
      队列里面有一些声明的辅助方法：
        enqueue(element)：向队列尾部添加新项。 push()
        dequeue()：移除队列的第一项，并返回被移除的元素。 shift()
        front()：返回队列中第一个元素，队列不做任何变动。
        isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。
        size()：返回队列包含的元素个数，与数组的 length 属性类似。
        print()：打印队列中的元素。
        clear()：清空整个队列。
  2. 优先队列
    1. 定义
      优先队列中元素的添加和移除是依赖优先级的。
    2. 应用
      一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。
      再比如：火车，老年人、孕妇和带小孩的乘客是享有优先检票权的。
    3. 优先队列分为两类
      最小优先队列
        最小优先队列是把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。
        比如：有四个元素："John", "Jack", "Camila", "Tom"，他们的优先级值分别为 4，3，2，1。
        那么最小优先队列排序应该为："Tom"，"Camila"，"Jack"，"John"。
      最大优先队列
        最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面。
        以上面的为例，最大优先队列排序应该为："John", "Jack", "Camila", "Tom"。
    4. 实现
      实现一个优先队列，有两种选项：
        设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除
        设置优先级，和普通队列一样正常按顺序添加，然后根据优先级移除
        这里最小优先队列和最大优先队列我都采用第一种方式实现，大家可以尝试一下第二种。
      下面只重写 enqueue() 方法和 print() 方法，其他方法和上面的普通队列完全相同。
        实现最小优先队列
        if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
  3. 循环队列
    1. 定义
      循环队列，顾名思义，它长得像一个环。把它想像成一个圆的钟就对了。
    2. 关键是：确定好队空和队满的判定条件。
      循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。
    下面我们在普通队列的基础上，实现一个模拟的击鼓传花游戏，下面只写击鼓传花的代码片段：
      // 实现击鼓传花
      function hotPotato (nameList, num) {
        var queue = new Queue();

        for (var i = 0; i < nameList.length; i++) {
          queue.enqueue(nameList[i]);
        }

        var eliminated = '';

        while (queue.size() > 1) {
          // 循环 num 次，队首出来去到队尾
          for (var i = 0; i < num; i++) {
            queue.enqueue(queue.dequeue());
          }
          // 循环 num 次过后，移除当前队首的元素
          eliminated = queue.dequeue();
          console.log(`${eliminated} 在击鼓传花中被淘汰！`);
        }

        // 最后只剩一个元素
        return queue.dequeue();
      }

      // 测试
      var nameList = ["John", "Jack", "Camila", "Ingrid", "Carl"];
      var winner = hotPotato(nameList, 10);
      console.log(`最后的胜利者是：${winner}`);




#### 链表
  1. 定义
    链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针 将 零散的内存块 串连起来的。
    每个元素由一个存储元素本身的 节点 和一个指向下一个元素的 引用（也称指针或链接）组成。
    简单的链接结构图：
      其中，data 中保存着数据，next 保存着下一个链表的引用。
      上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。值得注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。
  2. 特点
    *链表是通过指针将零散的内存块串连起来的。
    *所以链表不支持 随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。
    所以访问的时间复杂度为 O(n)。

    高效的插入和删除。
    链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。
    所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。

    三种最常见的链表结构，它们分别是：
      单链表
      双向链表
      循环链表
    1. 单链表
      1. 实现
        Node 类用来表示节点。
        LinkedList 类提供插入节点、删除节点等一些操作。
      2. 单向链表的八种常用操作：
        append(element)：尾部添加元素。
        insert(position, element)：特定位置插入一个新的项。
        removeAt(position)：特定位置移除一项。
        remove(element)：移除一项。
        indexOf(element)：返回元素在链表中的索引。如果链表中没有该元素则返回 -1。
        isEmpty()：如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false。
        size()：返回链表包含的元素个数，与数组的 length 属性类似。
        getHead()：返回链表的第一个元素。
        toString()：由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值。
        print()：打印链表的所有元素。
      3. 由于链表的起始点的确
      定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 头节点，表示链表的头部。
        经过改造，链表就成了如下的样子：
          有头节点的链表
        针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以插入与删除的时间复杂度为 O(1)。
      所以，在 JavaScript 中，单链表的真实数据有点类似于对象，实际上是 Node 类生成的实例。

    2. 双向链表
      单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。
      而双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。      
      1. 单向链表与又向链表比较
        双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。
        所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。
        虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。
        双向链表提供了两种迭代列表的方法：从头到尾，或者从尾到头。
        我们可以访问一个特定节点的下一个或前一个元素。
        在单向链表中，如果迭代链表时错过了要找的元素，就需要回到链表起点，重新开始迭代。
        在双向链表中，可以从任一节点，向前或向后迭代，这是双向链表的一个优点。
        所以，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

    3. 循环链表
      循环链表是一种特殊的单链表。
      循环链表和单链表相似，节点类型都是一样。
      唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性指向它本身。
      即：
      head.next = head;

  3. 链表总结
    写链表代码是最考验逻辑思维能力的，要熟练链表，只有 多写多练，没有捷径。
    因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。
    链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。
    所以，这也是很多面试官喜欢让人手写链表代码的原因。
    一定要自己写代码实现一下，才有效果。




