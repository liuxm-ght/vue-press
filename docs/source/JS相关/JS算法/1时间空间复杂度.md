#### 什么是好算法，什么是坏算法
  判断一个算法的好坏，一般从 执行时间 和 占用空间 来看,执行时间越短，占用的内存空间越小，那么它就是好的算法。
  对应的，我们常常用时间复杂度代表执行时间，空间复杂度代表占用的内存空间。

  ##### 时间复杂度
    时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。
    随着n的不断增大，时间复杂度不断增大，算法花费时间越多。 
  1. 常见的时间复杂度有
    常数阶O(1)
    对数阶O(log2 n)
    线性阶O(n)
    线性对数阶O(n log2 n)
    平方阶O(n^2)
    立方阶O(n^3)
    k次方阶O(n^K)
    指数阶O(2^n)

  2. 计算方法
    选取相对增长最高的项
    最高项系数是都化为1
    若是常数的话用O(1)表示

    举个例子：
      如:f(n)=3*n^4+3n+300 则 O(n)=n^4
        其中最高阶为3*n^4，系数化1，则为n^4
      如:let x= 1 while(x < 100){ x++ } 则 O(n)=1
        其中最高阶为 x,为常数，则 1
    
  ##### 空间复杂度
    空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。
    1. 计算方法：
      忽略常数，用O(1)表示
      递归算法的空间复杂度=(递归深度n)*(每次递归所要的辅助空间)
    
    2. 计算空间复杂度的简单几点
      仅仅只复制单个变量，空间复杂度为O(1)。举例如下：空间复杂度为O(n) = O(1)。
        let a = 1;
        let b = 2;
        let c = 3;
        console.log('输出a,b,c', a, b, c);

      递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O(n*1) = O(n)。
        function fun(n) {
          let k = 10;
          if (n == k) {
              return n;
          } else {
              return fun(++n)
          }
        }
