[[toc]]

## ES6 函数 新特性

### 参数
   1. 默认值
   2. 解构赋值与默认值结合
   ```ts
   function foo({x, y = 5}) {
   console.log(x, y);
   }

   foo({}) // undefined 5
   foo({x: 1}) // 1 5
   foo({x: 1, y: 2}) // 1 2
   foo() // TypeError: Cannot read property 'x' of undefined
   ```

### 属性
   1. length： 
      
      length将返回没有指定默认值的参数个数
      ```ts
      (function (a) {}).length // 1
      (function (a = 5) {}).length // 0
      (function (a, b, c = 5) {}).length // 2
      ```

      rest 参数也不会计入length属性
      ```ts
      (function(...args) {}).length // 0
      ```

      如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了
      ```ts
      (function (a = 0, b, c) {}).length // 0
      (function (a, b = 1, c) {}).length // 1
      ```

   2. name属性

      返回该函数的函数名
      ```ts
      var f = function () {};
      // ES5
      f.name // ""
      // ES6
      f.name // "f"
      ```

      如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字
      ```ts
      const bar = function baz() {};
      bar.name // "baz"
      ```

      Function构造函数返回的函数实例，name属性的值为anonymous
      ```ts
      (new Function).name // "anonymous"
      ```

      bind返回的函数，name属性值会加上bound前缀
     ```ts 
      function foo() {};
      foo.bind({}).name // "bound foo"

      (function(){}).bind({}).name // "bound "
      ```

### 作用域
   * 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域

   等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的

   下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x
   ```ts
   let x = 1;

   function f(y = x) { 
   // 等同于 let y = x  
   let x = 2; 
   console.log(y);
   }

   f() // 1
   ```

### 严格模式
   * 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

### 箭头函数

1.  总结：
    1. 箭头函数与普通函数的区别？
       1. 箭头函数不可作为构造函数，不能使用 new；因为没有 this，所以不能继承构造函数的私有属性和方法，所以不能被new
       2. 箭头函数没有自己的 this，箭头函数的 this 是其外层非箭头函数的 this；
       3. 箭头函数没有 arguments 对象
       4. 箭头函数没有原型对象
    2. 根本原因是箭头函数没有this，所以在预编译阶段没有进行this的指向确认，当箭头函数内使用到this时，this并没有绑定执行上下文