### 作用域
  * 作用域是指程序源代码中定义变量的区域。
  * 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
  * JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

  #### 静态作用域与动态作用域
  * 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
    而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

  1. 静态作用域
    让我们认真看个例子就能明白之间的区别：

  ```ts
    var value = 1;
    function foo() {
      console.log(value);
    }
    function bar() {
      var value = 2;
      foo();
    }
    bar();
    // 结果是 ???
  ```

    假设JavaScript采用静态作用域，让我们分析下执行过程：
      执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。
    假设JavaScript采用动态作用域，让我们分析下执行过程：
      执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。
    前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

  2. 动态作用域
    也许你会好奇什么语言是动态作用域？
      bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。
      ```ts
            value=1
            function foo () {
                echo $value;
            }
            function bar () {
                local value=2;
                foo;
            }
            bar
          //输出 2 
      ```




  #### 例子：
    1. 《JavaScript权威指南》中的例子：
  ```ts
    var scope = "global scope";
    function checkscope(){
      var scope = "local scope";
      function f(){
        return scope;
      }
      return f();
    }
    checkscope();

    var scope = "global scope";
    function checkscope(){
      var scope = "local scope";
      function f(){
        return scope;
      }
      return f;
    }
    checkscope()();

    // 分别打印：
      // "local scope"
      // "local scope"
  ```
        
        1. 分析：
          原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 
          而引用《JavaScript权威指南》的回答就是：
            * JavaScript 函数的执行用到了作用域链，这个作用域是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

        * 但是在这里真正想让大家思考的是：
          虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？

        * 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们来看下面 执行上下文栈 的介绍


### 执行上下文栈
  如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，
    毕竟：
  ```ts
    var foo = function () {
      console.log('foo1');
    }
    foo();  // foo1
    var foo = function () {
      console.log('foo2');
    }
    foo(); // foo2
  ```

    然而去看这段代码：
  ```ts
    function foo() {
      console.log('foo1');
    }
    foo();  // foo2
    function foo() {
      console.log('foo2');
    }
    foo(); // foo2
  ```
    打印的结果却是两个 foo2。

  刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。
  当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。

  但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？
  到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？

  #### 可执行代码
    这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？

    其实很简单，就三种，
      全局代码、
      函数代码、
      eval代码。

    举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，
      就叫做"执行上下文(execution context)"。

  #### 执行上下文栈
    接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？
      所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文

    为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：
      ECStack = [];
    试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，
    所以程序结束之前， ECStack 最底部永远有个 globalContext：
  ```ts
    ECStack = [
      globalContext
    ];
  ```
    
    现在 JavaScript 遇到下面的这段代码了：
  ```ts
    function fun3() {
      console.log('fun3')
    }
    function fun2() {
      fun3();
    }
    function fun1() {
      fun2();
    }
    fun1();
  ```
    当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：
  ```ts
    // 伪代码
    // fun1()
    ECStack.push(<fun1> functionContext);

    // fun1中竟然调用了fun2，还要创建fun2的执行上下文
    ECStack.push(<fun2> functionContext);

    // 擦，fun2还调用了fun3！
    ECStack.push(<fun3> functionContext);

    // fun3执行完毕
    ECStack.pop();

    // fun2执行完毕
    ECStack.pop();

    // fun1执行完毕
    ECStack.pop();

    // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
  ```
  ##### 解答思考题
    好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题：
  ```ts
    var scope = "global scope";
    function checkscope(){
        var scope = "local scope";
        function f(){
            return scope;
        }
        return f();
    }
    checkscope();

    var scope = "global scope";
    function checkscope(){
        var scope = "local scope";
        function f(){
            return scope;
        }
        return f;
    }
    checkscope()();

    两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？

      答案就是执行上下文栈的变化不一样。
        让我们模拟第一段代码：
        ECStack.push(<checkscope> functionContext);
        ECStack.push(<f> functionContext);
        ECStack.pop();
        ECStack.pop();

        让我们模拟第二段代码：
        ECStack.push(<checkscope> functionContext);
        ECStack.pop();
        ECStack.push(<f> functionContext);
        ECStack.pop();
  ```
  - 是不是有些不同呢？
      - 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。
  
  ##### 总结
    作用域 与 执行上下文栈 的角度来理解上面的两段代码：
  1. 作用域角度来说，
        两段代码都是 全局作用域globalScope -> 函数作用域checkscope -> 函数作用域f
        f里的变量scope都是在这条作用域链上查找值的，所以结果输出是一样的！！！
    * 跟执行位置无关
  2. 执行上下文栈角度来说，
        第一段代码是  压入 全局执行上下文globalCtx -> 函数上下文checkFnCtx -> 函数上下文fFnCtx 
                    弹出 函数上下文fFnCtx -> 函数上下文checkFnCtx -> 全局执行上下文globalCtx
        第二段代码是  压入 全局执行上下文globalCtx -> 函数上下文checkFnCtx 
                    弹出 -> 函数上下文checkFnCtx 
                    压入 -> 函数上下文fFnCtx 
                    弹出 -> 函数上下文fFnCtx -> 全局执行上下文globalCtx
    * 跟执行位置有关，执行的位置不一样，执行栈顺序也就不一样


    

### 执行上下文（重要属性）
  * 当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。
  - 对于每个执行上下文，都有三个重要属性：
     - 作用域链(Scope chain)
     - 变量对象(Variable object，VO)
     - this

### 变量对象
  1. 变量对象VO
    变量对象 存储了在上下文中定义的 变量 和 函数声明

    1. 全局上下文中的变量对象 -- 全局对象
      简单来说，被激活的全局上下文中的变量对象 就叫 全局对象

    2. 函数上下文中的变量对象 -- 活动对象AO
        活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。
      简单来说，被激活的函数上下文中的变量对象 就叫 活动对象AO
        活动对象是进入函数上下文那一刻才被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

  2. 执行过程
    执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：
      1. 进入执行上下文 分析               ---------------      (即JS的预处理阶段 - 在《JS解析与执行流程》有详细说明)
        当进入执行上下文时，这时候还没有执行代码，开始激活变量对象，最终成为活动对象AO
          变量对象会包括：
          1. 函数的所有形参 (如果是函数上下文)
            由名称和对应值组成的一个变量对象的属性被创建
            没有实参，属性值设为 undefined
          2. 函数声明
            由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
            如果变量对象已经存在相同名称的属性，则完全替换这个属性
          3. 变量声明
            由名称和对应值（undefined）组成一个变量对象的属性被创建；
            如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
          ps: 可以看出，函数的声明会在变量声明之前，但是同名的变量声明不会覆盖函数的声明
      2. 代码执行 执行                  ---------------      (即JS的运行阶段 - 在《JS解析与执行流程》有详细说明)
        在代码执行阶段，会顺序执行代码，根据代码，修改活动对象AO的值
  
  3. 总结
      1. 全局上下文的变量对象初始化是全局对象
      2. 函数上下文的变量对象初始化只包括 Arguments 对象
      3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值(即准备阶段)
      4. 在代码执行阶段，会再次修改变量对象的属性值

    简单来说，进入函数上下文那一刻创建变量对象，然后开始分析激活变量对象成为活动对象，然后执行代码改变活动对象的属性值

  4. 例子
    举个例子：
  ```ts
    function foo(a) {
      var b = 2;
      function c() {}
      var d = function() {};
      b = 3;
      function Foo() {}
      var Foo = 5 // 这个Foo属性不会添加到变量对象中去
      <!-- console.log(Foo,'Foo') -->
    }
    foo(1);
  ```

    在进入执行上下文后，这时候的 VO 是：
  ```ts
    VO = {
      arguments: {
        0: 1,
        length: 1
      },
      a: 1,
      b: undefined,
      c: reference to function c(){},
      d: undefined,
      Foo: reference to function Foo(){},
    }
  ```
    执行代码之后，VO变成AO是这样的：
  ```ts
    AO = {
      arguments: {
          0: 1,
          length: 1
      },
      a: 1,
      b: 3,
      c: reference to function c(){},
      d: reference to FunctionExpression "d",
      Foo: 5
    }
  ```


  5. 注意：
      1. AO 实际上是包含了 VO 的。因为除了 VO 之外，AO 还包含函数的 parameters，以及 arguments 这个特殊对象。也就是说 AO 的确是在进入到执行阶段的时候被激活，但是激活的除了 VO 之外，还包括函数执行时传入的参数和 arguments 这个特殊对象。
      - AO = VO + function parameters + arguments


  6. 以下是解释器如何评估代码的伪概述：
      1. 找些代码来调用一个函数
      2. 在执行函数代码之前，创建执行上下文。
      3. 进入创建阶段:               ---------------      (即JS的预处理阶段 - 在《JS解析与执行流程》有详细说明)
          1. 初始化作用域链
          2. 创建变量对象：
            创建arguments对象，检查参数的上下文，初始化名称和值并创建引用的副本。
          3. 扫描上下文以获取函数声明：
            对于找到的每个函数，在变量对象（或活动对象）中创建一个属性，该属性是确切的函数名称，该函数具有指向内存中函数的引用指针。
            如果函数名已存在，则将覆盖引用指针值。
          4. 扫面上下文以获取变量声明：
            对于找到的每个变量声明，在变量对象（或活动对象）中创建一个属性，该属性是变量名称，并将值初始化为undefined。
            如果变量名称已存在于变量对象（或活动对象）中，则不执行任何操作并继续扫描（即跳过）。
          5. 确定上下文中的this。
      4. 激活/代码执行阶段:                  ---------------      (即JS的运行阶段 - 在《JS解析与执行流程》有详细说明)
        在上下文中运行/解释功能代码，并在代码逐行执行时分配变量值。
    
  7. Foo被声明了两次，为什么foo显示为函数而不是undefined或string呢？
    即使foo被声明了两次，我们从创建阶段中就知道到达变量之前在活动对象上已经创建了函数，并且如果活动对象上已经存在属性名称，我们就会绕过了声明。
    因此，首先在活动对象上创建函数foo()的引用，并且当解释器到达var foo时，我们已经看到名称foo存在，因此代码什么都不做并且继续。
    <!-- 参考文章：https://juejin.cn/post/6844903793910349832 -->


### 作用域链
  作用域链
    在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

  * 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。

  1. 函数创建
      * 在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。
      * 这是因为函数有一个内部属性 [[Scopes]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[Scopes]] 就是所有父变量对象的层级链，但是注意：[[Scopes]] 并不代表完整的作用域链！

        举个例子：
      ```ts
        function foo() {
            function bar() {
                congsole.log(111)
            }
        }
      ```
        函数创建时，各自的[[scope]]为：
      ```ts
        foo.[[Scopes]] = [
          globalContext.VO
        ];

        bar.[[Scopes]] = [
            fooContext.VO,
            globalContext.VO
        ];
      ```

  2. 函数激活
      1. 当函数激活时，进入函数上下文，创建 VO 后，就会将活动对象添加到作用链的前端。
      2. 这时候执行上下文的作用域链，我们命名为 Scopes:
      ```ts
        Scopes = [AO].concat([[Scopes]]);
      ```
        此时：
      ```ts
      bar.[[Scopes]] = [
          barContext.AO,
          fooContext.AO, //此时肯定执行了foo函数，所以是AO
          globalContext.VO
      ];
      ```
      至此，作用域链创建完毕。

  * 捋一捋
      * 以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：
      ```ts
        var scope = "global scope";
        function checkscope(){
            var scope2 = 'local scope';
            return scope2;
        }
        checkscope();
      ```

  * 执行过程如下：
      1. checkscope 函数被创建，保存作用域链到 内部属性[[scope]]
      ```ts
      checkscope.[[scope]] = [
          globalContext.VO
      ];
      ```

      2. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈
      ```ts
      ECStack = [
          checkscopeContext,
          globalContext
      ];
      ```

      3. checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

      ```ts
      checkscopeContext = {
          Scope: checkscope.[[scope]],
      }
      ```

      4. 第二步：用 arguments 创建变量对象，随后初始化变量对象，加入形参、函数声明、变量声明
      ```ts
      checkscopeContext = {
          VO: {
              arguments: {
                  length: 0
              },
              scope2: undefined
          }，
          Scope: checkscope.[[scope]],
      }
      ```

      5. 第三步：将变量对象压入 checkscope 作用域链顶端
      ```ts
      checkscopeContext = {
          VO: {
              arguments: {
                  length: 0
              },
              scope2: undefined
          },
          Scope: [VO, [[Scope]]]
      }
      ```

      6. 准备工作做完，开始执行函数，激活变量对象成为活动对象AO，随着函数的执行，修改 AO 的属性值
      ```ts
      checkscopeContext = {
          AO: {
              arguments: {
                  length: 0
              },
              scope2: 'local scope'
          },
          Scope: [AO, [[Scope]]]
      }
      ```

      7. 查找到 scope2 的值(在AO中找到了，如果没找到去globalContext.VO找)，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
      ```ts
      ECStack = [
          globalContext
      ];
      ```

### 总结：
  1. 作用域是全局或函数或eval环境下，变量可查询的范围，即变量对象(存储了环境的所有变量、函数等被声明的变量，函数的话还包括参数对象)
  2. 作用域链是在执行前确定的，例如函数执行前会将当前函数上下文的作用域加入到其作用域链属性中去，其变量的查询就在这个链上查询
  3. 执行栈是浏览器开辟的用来存储执行上下文的内存，遵从LIFO(后进先出)，栈顶是当前运行的执行上下文，执行完弹出栈，最后弹出的肯定是全局执行上下文
  4. 执行上下文是代码执行的环境，包括作用域(变量对象)、作用域链、this，这些都是在函数执行前几秒创建的用来存储变量