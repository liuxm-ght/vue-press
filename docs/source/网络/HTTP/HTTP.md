### HTTP
  介绍： 
    HTTP全称Hyper Text Transfer Protocol，即超文本传输协议。
    HTTP是一个应用层协议，可视为一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。
    <!-- https://www.jianshu.com/p/6e9e4156ece3 -->

  1. HTTP报文结构
    起始行 + 头部 + 空行 + 实体
      1. 请求报文
          1. 起始行
              方法 + url路径 + 协议版本
            eg: GET /home HTTP/1.1
          2. 头部
            key-value 格式
            <!-- 首部详解：https://blog.csdn.net/m0_53248894/article/details/118073546 -->
          3. 空格
            区分头部和实体
          4. 实体
            具体数据 请求体
      2. 响应报文
          1. 状态行
              版本 + 状态 + 原因
            eg: HTTP/1.1 200 OK
          2. 头部
            key-value 格式
          3. 空格
            区分头部和实体
          4. 实体
            具体数据 响应体
  
  2. 请求方法
    GET: 通常用来获取资源
    HEAD: 获取资源的元信息
    POST: 提交数据，即上传数据
    PUT: 修改数据
    DELETE: 删除资源(几乎用不到)
    CONNECT: 建立连接隧道，用于代理服务器
    OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
    TRACE: 追踪请求-响应的传输路径

  3. GET和POST请求的区别
    1. 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
    2. 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
    3. 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
    4. 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
    5. 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

  4. 如何理解 URI？
    URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。
    但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。
    1. URI结构：
      URN + URL
      scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。
      user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
      host:port表示主机名和端口。
      path表示请求路径，标记资源所在位置。
      query表示查询参数，为key=val这种形式，多个键值对之间用&隔开。
      fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。
    2. URI 编码
      URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
      因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
      如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。

  5. HTTP 状态码
    RFC 规定 HTTP 的状态码为三位数，被分为五类:
      1xx: 表示目前是协议处理的中间状态，还需要后续操作。
      2xx: 表示成功状态。
      3xx: 重定向状态，资源位置发生变动，需要重新请求。
      4xx: 请求报文有误。
      5xx: 服务器端发生错误。
    常见的：  
      200 OK是见得最多的成功状态码。通常在响应体中放有数据
      301 Moved Permanently即永久重定向
      302 Found，即临时重定向
      304 Not Modified 当协商缓存命中时会返回这个状态码
      403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
      404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
      500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
      502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
      503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。
      <!-- https://juejin.cn/post/6844904100035821575 -->

  6. HTTP 特点 和 缺点
    特点：
      可靠传输：HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
      请求-应答：也就是一发一收、有来有回， 
      无状态：这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。
    缺点：
      * 无状态
      <!-- 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
      在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
      但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。 -->
      * 使用明文通信，一些重要的内容会被窃听；
      * 不能验证对方身份，可能是伪造的信息；(中间人攻击)
      * 无法验证报文的完整性，有可能被修改；
      <!-- https://www.cnblogs.com/jojop/p/14111938.html -->
    
  7. 表单提交
    一般为POST请求，大概有两种,体现在两种不同的Content-Type取值：
      1. application/x-www-form-urlencoded
        其中的数据会被编码成以&分隔的键值对
        字符以URL编码方式编码。
        eg:
          // 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
          "a%3D1%26b%3D2"
      2. multipart/form-data
        <!-- 请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。
        数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。
          eg:   
            Content-Disposition: form-data;name="data1";
            Content-Type: text/plain
            data1
            ----WebkitFormBoundaryRRJKeWfHPGrS4LKe
            Content-Disposition: form-data;name="data2";
            Content-Type: text/plain
            data2
            ----WebkitFormBoundaryRRJKeWfHPGrS4LKe-- -->
      小结：  
      在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。

  8. 队头阻塞问题
      什么事队头阻塞？
        在HTTP1.0的时代，HTTP每发送一个请求就需要建立一次TCP连接，而且还是串行执行，开销大，服务端压力也大，
        进入HTTP1.1的时代，HTTP有了个 长连接(持久连接)，建立一次TCP连接，即可开通管道，可实现发送多个请求，但是服务器应答还是按请求顺序应答的，这样队头响应慢时，就会阻塞后面的响应了。
        <!-- HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。 -->
      <!-- 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。 -->
      解决：
        并发连接：
          同一域名浏览器可支持2-10个并发TCP连接，但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。
        域名分片：
          使用二级域名，增加可并发连接数
          <!-- 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
          比如 content1.sanyuan.com 、content2.sanyuan.com。
          这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。 -->

  9. Cookie
      1. 介绍:
        由于HTTP的无状态特点，但有时候需要保存状态，为此HTTP引入了Cookie来存储这些状态。
        Cookie本质是浏览器上存储的一个小小的文件，内部以键值对的方式来存储信息。同域名下得请求发送时，都会携带Cookie，
        服务器拿到Cookie解析，便能拿到客户端的状态了。
        而服务器响应的Set-Cookie字段可以往客户端上写入Cookie。
        例子:
          // 请求头
          Cookie: a=xxx;b=xxx
          // 响应头
          Set-Cookie: a=xxx
          set-Cookie: b=xxx
      2. Cookie 属性
          1. 生存周期
            Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。
              1. Expires 即过期时间
              2. Max-Age 用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。
              若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。
          2. 作用域
            关于作用域也有两个属性: 
              Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。
              值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。
          3. 安全相关
              1. 如果带上Secure，说明只能通过 HTTPS 传输 cookie。
              2. 如果 cookie 字段带上HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。
              3. 相应的，对于 CSRF 攻击的预防，也有SameSite属性。
                SameSite可以设置为三个值，Strict、Lax和None。
                a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
                b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
                c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。
      3. Cookie 缺点
          1. 容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。
          2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
            但可以通过Domain和Path指定作用域来解决。即
              * 静态资源分组，分别放到不同的域名下（如static.base.com）
              * 同时配合 dns-prefetch (浏览器提前解析dns域名)
          3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。(所以cookie是不允许存放敏感信息的，如果需要设置HttpOnly为true)

  10. 如何理解 HTTP 代理？
      <!-- 我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。
      当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。
      那代理服务器到底是用来做什么的呢？ -->
      功能
      1. 负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。
      2. 保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
      3. 缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。
      <!-- https://juejin.cn/post/6844904100035821575 -->
      相关头部字段：via X-Forwarded-For X-Real-IP

  11. 如何理解 HTTP 缓存及缓存代理？
      1. 请求过程涉及的缓存大概有：
        HTTP缓存有：强缓存 与 协商缓存
        源服务器缓存有：redis、Memcache等；
          但是如果HTTP缓存失效都去源服务器拿，对源服务器来说也是很大压力的；
          所以有
        代理缓存:
          客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器
      2. 如何缓存代理？
        总的来说，缓存代理的控制分为两部分，一部分是源服务器端的控制，一部分是客户端的控制。
        1. 源服务器端
          private 和 public
            <!-- 在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入private或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。
            比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的Cache-Control设为private，而不是public。 -->
          proxy-revalidate
            <!-- must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取。 -->
          s-maxage
            <!-- s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突。
            讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:
            Cache-Control: public, max-age=1000, s-maxage=2000
            相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。 -->
        2. 客户端
          max-stale 和 min-fresh
            <!-- 在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。比如：
            max-stale: 5
              表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在5秒之内，还是可以从代理中获取的。
            又比如:
              min-fresh: 5
              表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。 -->
          only-if-cached
            <!-- 这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504（Gateway Timeout）。 -->

  12. 跨域
      需要清楚两个概念: 
        1. 简单请求
          浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于简单请求
            * 请求方法为 GET、POST 或者 HEAD
            * 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)
          请求发出去之前，浏览器做了什么？
            1. Origin字段：它会自动在请求头当中，添加一个Origin字段，用来说明请求来自哪个源。
              服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，如果Origin不在这个字段的范围中，那么浏览器就会将响应拦截。
              因此，Access-Control-Allow-Origin字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。
            * Access-Control-Allow-Credentials。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性:
              let xhr = new XMLHttpRequest();
              xhr.withCredentials = true;
            <!-- 链接：https://juejin.cn/post/6844904100035821575 -->
            * Access-Control-Expose-Headers。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）, 还能拿到这个字段声明的响应头字段。比如这样设置:
              Access-Control-Expose-Headers: aaa
              那么在前端可以通过 XMLHttpRequest.getResponseHeader('aaa') 拿到 aaa 这个字段的值。
        2. 非简单请求
          非简单请求相对而言会有些不同，体现在两个方面: 预检请求和响应字段。
            1. 预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:
              Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法
              Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头
            2. 响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。
            在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。
            CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。
      <!-- 其他详情见《跨域》篇 -->

  13. HTTP请求流程  
      HTTP协议是由客户端发起的，由请求和响应构成，是一个标准的客户端服务器模型（C/S），它的具体流程如下：
        1. 地址解析。域名系统DNS解析域名得到主机的IP地址；
        2. 封装HTTP请求数据包。封装的内容有以上部分结合本机自己的信息；
        3. 封装成TCP包，建立TCP连接(TCP的三次握手)；
        4. 客户机发送请求命令。 建立连接后，客户机向服务器发送一个GET请求；发送请求报文起始行，请求头部，空格表示头部完成；
        5. 服务器响应。服务器接到请求后，给予相应的响应信息；返回响应报文状态行，响应头部，空格表示头部完成，根据content-Type返回数据；
        6. 服务器关闭TCP连接(四次挥手)：一般Web服务器向浏览器发送了请求数据，它要关闭TCP连接；
        7. 客户端解析报文。客户端接收到响应报文后解析HTML代码，并渲染。





        




<!-- 
14. 其他
  1. gzip压缩
    首先，明确gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）
    然后gzip一般是由apache、tomcat等web服务器开启
    当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）
    所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。 

  2. 长连接与短连接
    首先看tcp/ip层面的定义：
      长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）

      短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

    然后在http层面：
      http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接

      http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接
    注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效 
-->